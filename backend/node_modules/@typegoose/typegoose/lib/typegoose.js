"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDiscriminatorModelForClass = exports.deleteModelWithClass = exports.deleteModel = exports.addModelToTypegoose = exports.buildSchema = exports.getModelWithString = exports.getModelForClass = exports.setGlobalOptions = exports.mongoose = void 0;
const tslib_1 = require("tslib");
/* imports */
const mongoose = require("mongoose");
exports.mongoose = mongoose;
require("reflect-metadata");
const semver = require("semver");
const utils_1 = require("./internal/utils");
/* istanbul ignore next */
if (!utils_1.isNullOrUndefined(process === null || process === void 0 ? void 0 : process.version) && !utils_1.isNullOrUndefined(mongoose === null || mongoose === void 0 ? void 0 : mongoose.version)) { // for usage on client side
    /* istanbul ignore next */
    if (semver.lt(mongoose === null || mongoose === void 0 ? void 0 : mongoose.version, '5.9.14')) {
        throw new Error('Please use mongoose 5.9.14 or higher [E001]');
    }
    /* istanbul ignore next */
    if (semver.lt(process.version.slice(1), '10.15.0')) {
        throw new Error('You are using a NodeJS Version below 10.15.0, Please Upgrade! [E002]');
    }
}
const globalOptions_1 = require("./globalOptions");
Object.defineProperty(exports, "setGlobalOptions", { enumerable: true, get: function () { return globalOptions_1.setGlobalOptions; } });
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const schema_1 = require("./internal/schema");
const logSettings_1 = require("./logSettings");
const typeguards_1 = require("./typeguards");
var logSettings_2 = require("./logSettings");
Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function () { return logSettings_2.setLogLevel; } });
Object.defineProperty(exports, "LogLevels", { enumerable: true, get: function () { return logSettings_2.LogLevels; } });
tslib_1.__exportStar(require("./prop"), exports);
tslib_1.__exportStar(require("./hooks"), exports);
tslib_1.__exportStar(require("./plugin"), exports);
tslib_1.__exportStar(require("./index"), exports);
tslib_1.__exportStar(require("./modelOptions"), exports);
tslib_1.__exportStar(require("./queryMethod"), exports);
tslib_1.__exportStar(require("./typeguards"), exports);
exports.defaultClasses = require("./defaultClasses");
exports.errors = require("./internal/errors");
exports.types = require("./types");
var utils_2 = require("./internal/utils");
Object.defineProperty(exports, "getClassForDocument", { enumerable: true, get: function () { return utils_2.getClassForDocument; } });
Object.defineProperty(exports, "getClass", { enumerable: true, get: function () { return utils_2.getClass; } });
Object.defineProperty(exports, "getName", { enumerable: true, get: function () { return utils_2.getName; } });
var constants_2 = require("./internal/constants");
Object.defineProperty(exports, "Severity", { enumerable: true, get: function () { return constants_2.Severity; } });
globalOptions_1.parseENV(); // call this before anything to ensure they are applied
/**
 * Get a Model for a Class
 * Executes .setModelForClass if it can't find it already
 * @param cl The uninitialized Class
 * @returns The Model
 * @public
 * @example
 * ```ts
 * class Name {}
 *
 * const NameModel = getModelForClass(Name);
 * ```
 */
function getModelForClass(cl, options) {
    var _a, _b, _c, _d, _e, _f;
    utils_1.assertionIsClass(cl);
    options = typeof options === 'object' ? options : {};
    const roptions = utils_1.mergeMetadata(constants_1.DecoratorKeys.ModelOptions, options, cl);
    const name = utils_1.getName(cl);
    if (data_1.models.has(name)) {
        return data_1.models.get(name);
    }
    const model = (_d = (_b = (_a = roptions === null || roptions === void 0 ? void 0 : roptions.existingConnection) === null || _a === void 0 ? void 0 : _a.model.bind(roptions.existingConnection)) !== null && _b !== void 0 ? _b : (_c = roptions === null || roptions === void 0 ? void 0 : roptions.existingMongoose) === null || _c === void 0 ? void 0 : _c.model.bind(roptions.existingMongoose)) !== null && _d !== void 0 ? _d : mongoose.model.bind(mongoose);
    const compiledmodel = model(name, buildSchema(cl, roptions.schemaOptions));
    const refetchedOptions = (_e = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl)) !== null && _e !== void 0 ? _e : {};
    if ((_f = refetchedOptions === null || refetchedOptions === void 0 ? void 0 : refetchedOptions.options) === null || _f === void 0 ? void 0 : _f.runSyncIndexes) {
        // no async/await, to wait for execution on connection in the background
        compiledmodel.syncIndexes();
    }
    return addModelToTypegoose(compiledmodel, cl);
}
exports.getModelForClass = getModelForClass;
/**
 * Get Model from internal cache
 * @param key ModelName key
 * @example
 * ```ts
 * class Name {}
 * getModelForClass(Name); // build the model
 * const NameModel = getModelWithString<typeof Name>("Name");
 * ```
 */
function getModelWithString(key) {
    utils_1.assertion(typeof key === 'string', TypeError(`Expected "key" to be a string, got "${key}"`));
    return data_1.models.get(key);
}
exports.getModelWithString = getModelWithString;
/**
 * Generates a Mongoose schema out of class props, iterating through all parents
 * @param cl The not initialized Class
 * @returns Returns the Build Schema
 * @example
 * ```ts
 * class Name {}
 * const NameSchema = buildSchema(Name);
 * const NameModel = mongoose.model("Name", NameSchema);
 * ```
 */
function buildSchema(cl, options) {
    utils_1.assertionIsClass(cl);
    logSettings_1.logger.debug('buildSchema called for "%s"', utils_1.getName(cl));
    const mergedOptions = utils_1.mergeSchemaOptions(options, cl);
    let sch;
    /** Parent Constructor */
    let parentCtor = Object.getPrototypeOf(cl.prototype).constructor;
    // iterate trough all parents
    while ((parentCtor === null || parentCtor === void 0 ? void 0 : parentCtor.name) !== 'Object') {
        // extend schema
        sch = schema_1._buildSchema(parentCtor, sch, mergedOptions, false);
        // set next parent
        parentCtor = Object.getPrototypeOf(parentCtor.prototype).constructor;
    }
    // get schema of current model
    sch = schema_1._buildSchema(cl, sch, mergedOptions);
    return sch;
}
exports.buildSchema = buildSchema;
/**
 * This can be used to add custom Models to Typegoose, with the type information of cl
 * Note: no gurantee that the type information is fully correct
 * @param model The model to store
 * @param cl The Class to store
 * @example
 * ```ts
 * class Name {}
 *
 * const schema = buildSchema(Name);
 * // modifications to the schame can be done
 * const model = addModelToTypegoose(mongoose.model("Name", schema), Name);
 * ```
 */
function addModelToTypegoose(model, cl) {
    utils_1.assertion(model.prototype instanceof mongoose.Model, new TypeError(`"${model}" is not a valid Model!`));
    utils_1.assertionIsClass(cl);
    const name = utils_1.getName(cl);
    utils_1.assertion(!data_1.models.has(name), new Error('It seems like "addModelToTypegoose" got called twice\n' +
        'Or multiple classes with the same name are used, which is not supported!' +
        `(Model Name: "${name}") [E003]`));
    if (data_1.constructors.get(name)) {
        logSettings_1.logger.info('Class "%s" already existed in the constructors Map', name);
    }
    data_1.models.set(name, model);
    data_1.constructors.set(name, cl);
    return data_1.models.get(name);
}
exports.addModelToTypegoose = addModelToTypegoose;
/**
 * Deletes an existing model so that it can be overwritten
 * with another model
 * (deletes from mongoose.connection & typegoose models cache & typegoose constructors cache)
 * @param key
 * @example
 * ```ts
 * class Name {}
 * const NameModel = getModelForClass(Name);
 * deleteModel("Name");
 * ```
 */
function deleteModel(name) {
    utils_1.assertion(typeof name === 'string', new TypeError('name is not an string! (deleteModel)'));
    utils_1.assertion(data_1.models.has(name), new Error(`Model "${name}" could not be found`));
    logSettings_1.logger.debug('Deleting Model "%s"', name);
    data_1.models.get(name).db.deleteModel(name);
    data_1.models.delete(name);
    data_1.constructors.delete(name);
}
exports.deleteModel = deleteModel;
/**
 * Delete a model, with the given class
 * Same as "deleteModel", only that it can be done with the class instead of the name
 * @param cl The Class
 * @example
 * ```ts
 * class Name {}
 * const NameModel = getModelForClass(Name);
 * deleteModelWithClass(Name);
 * ```
 */
function deleteModelWithClass(cl) {
    utils_1.assertionIsClass(cl);
    return deleteModel(utils_1.getName(cl));
}
exports.deleteModelWithClass = deleteModelWithClass;
/**
 * Build a Model from a given class and return the model
 * @param from The Model to build From
 * @param cl The Class to make a model out
 * @param value The Identifier to use to differentiate documents (default: cl.name)
 * @example
 * ```ts
 * class C1 {}
 * class C2 extends C1 {}
 *
 * const C1Model = getModelForClass(C1);
 * const C2Model = getDiscriminatorModelForClass(C1Model, C1);
 * ```
 */
function getDiscriminatorModelForClass(from, cl, value) {
    utils_1.assertion(typeguards_1.isModel(from), new TypeError(`"${from}" is not a valid Model!`));
    utils_1.assertionIsClass(cl);
    const name = utils_1.getName(cl);
    if (data_1.models.has(name)) {
        return data_1.models.get(name);
    }
    const sch = buildSchema(cl);
    const discriminatorKey = sch.get('discriminatorKey');
    if (sch.path(discriminatorKey)) {
        sch.paths[discriminatorKey].options.$skipDiscriminatorCheck = true;
    }
    const model = from.discriminator(name, sch, value ? value : name);
    return addModelToTypegoose(model, cl);
}
exports.getDiscriminatorModelForClass = getDiscriminatorModelForClass;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZWdvb3NlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3R5cGVnb29zZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsYUFBYTtBQUNiLHFDQUFxQztBQW1DNUIsNEJBQVE7QUFsQ2pCLDRCQUEwQjtBQUMxQixpQ0FBaUM7QUFFakMsNENBQThIO0FBRTlILDBCQUEwQjtBQUMxQixJQUFJLENBQUMseUJBQWlCLENBQUMsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMseUJBQWlCLENBQUMsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsMkJBQTJCO0lBQzlHLDBCQUEwQjtJQUMxQixJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsRUFBRTtRQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7S0FDaEU7SUFFRCwwQkFBMEI7SUFDMUIsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxFQUFFO1FBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsc0VBQXNFLENBQUMsQ0FBQztLQUN6RjtDQUNGO0FBRUQsbURBQTZEO0FBZ0IxQyxpR0FoQkEsZ0NBQWdCLE9BZ0JBO0FBZm5DLG9EQUFxRDtBQUNyRCwwQ0FBdUQ7QUFDdkQsOENBQWlEO0FBQ2pELCtDQUF1QztBQUN2Qyw2Q0FBdUM7QUFZdkMsNkNBQXVEO0FBQTlDLDBHQUFBLFdBQVcsT0FBQTtBQUFFLHdHQUFBLFNBQVMsT0FBQTtBQUMvQixpREFBdUI7QUFDdkIsa0RBQXdCO0FBQ3hCLG1EQUF5QjtBQUN6QixrREFBd0I7QUFDeEIseURBQStCO0FBQy9CLHdEQUE4QjtBQUM5Qix1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